//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace sliver.AccessQueryAnalyzer {
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Runtime.Serialization.Json;

	/// <summary>
	/// Replaces the auto-generated ApplicationSettings implementation with a lightweight
	/// JSON-backed settings store. Keeps the same API surface used in the project:
	///   - static Default instance
	///   - property LastDatabase
	///   - Save() method
	/// The settings are kept in-memory in a Dictionary and persisted to "%AppData%\AccessQueryAnalyzer\settings.json".
	/// </summary>
	internal sealed class Settings {
		private static readonly Settings defaultInstance = new Settings();
		public static Settings Default {
			get {
				return defaultInstance;
			}
		}

		private readonly object syncRoot = new object();
		private readonly string filePath;
		private Dictionary<string, string> store;

		private Settings() {
			string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
			string dir = Path.Combine(appData, "AccessQueryAnalyzer");
			try {
				if (!Directory.Exists(dir)) {
					Directory.CreateDirectory(dir);
				}
			}
			catch {
				// ignore. If we cannot create the directory, fall back to current directory path
				dir = AppDomain.CurrentDomain.BaseDirectory ?? Environment.CurrentDirectory;
			}

			filePath = Path.Combine(dir, "settings.json");
			LoadFromDisk();
		}

		private void LoadFromDisk() {
			lock (syncRoot) {
				store = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
				if (!File.Exists(filePath))
					return;

				try {
					using (FileStream fs = File.OpenRead(filePath)) {
						var serializer = new DataContractJsonSerializer(typeof(Dictionary<string, string>));
						var obj = serializer.ReadObject(fs) as Dictionary<string, string>;
						if (obj != null) {
							store = obj;
						}
					}
				}
				catch {
					// ignore parse/read errors and start with an empty store
					store = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
				}
			}
		}

		/// <summary>
		/// Persist current in-memory settings to disk. Swallows exceptions to avoid crashing UI.
		/// </summary>
		public void Save() {
			lock (syncRoot) {
				try {
					using (FileStream fs = File.Create(filePath)) {
						var serializer = new DataContractJsonSerializer(typeof(Dictionary<string, string>));
						serializer.WriteObject(fs, store);
					}
				}
				catch {
					// intentionally ignore IO errors
				}
			}
		}

		/// <summary>
		/// Generic accessor if you need additional keys later.
		/// </summary>
		public string Get(string key, string defaultValue = "") {
			if (string.IsNullOrEmpty(key))
				return defaultValue;

			lock (syncRoot) {
				if (store.TryGetValue(key, out string v))
					return v ?? defaultValue;
				return defaultValue;
			}
		}

		/// <summary>
		/// Generic setter for additional keys.
		/// </summary>
		public void Set(string key, string value) {
			if (string.IsNullOrEmpty(key))
				return;

			lock (syncRoot) {
				store[key] = value ?? string.Empty;
			}
		}
	}
}
